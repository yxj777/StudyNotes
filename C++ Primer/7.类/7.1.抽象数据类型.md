# 类的基本思想
## 数据抽象(data abstraction)
  - 依赖与**接口**和**实现**分离的编程技术
    - 接口：用户所能执行的操作
    - 实现：类的数据成员、接口实现的函数体，定义类所需的私有函数
## 封装(encapsulation)
  - 实现了类的接口和实现的分离，隐藏实现细节

# 抽象数据类型
- 封装（隐藏）了实现细节的数据结构
- 类的设计者考虑实现过程
- 使用者只需抽象思考类型做了什么
  
# 成员函数
- 声明必须在类的内部，定义可内部外部
## 外部定义成员函数
  - 成员函数的名字必须包含它所属的类名
```c++
void Cex::example(void) {}
```
## this指针
  - 指向调用函数的对象
  - 是一个隐式的值，作为额外的实参传递给类的每个非静态成员函数
  - 默认情况下，this类型为：指向非常量成员的常量指针
  ```c++
  string example() { return x; }
  //实际调用过程，伪代码
  string example(调用对象类型 *const this) { return this->x; }
  ```
  - 也可以返回this，返回调用函数的对象
  ```c++
  exObj& Cexample::combine(const exObj &rhs)
  {
    x += rhs.x;   //把rhs成员加到this成员上
    y += rhs.y;
    return *this; //返回调用该函数的对象
  }
  ```
## const成员函数
  - 也被称作**常量成员函数**(const member function)
  - 不能修改对象的数据成员
  - this指针变为：指向常量成员的常量指针
  - 提高函数灵活性，使this能指向常量
  ```c++
  string example() const { return x; }
  //实际调用过程，伪代码
  string example(const 调用对象类型 *const this)  { return this->x; }
  ```
# 非成员函数
- 属于类的接口的组成部分，但不属于类本身
- 如果非成员函数为类接口组成部分，则其声明与类声明放在同一个头文件中

# 构造函数
- 用于初始化对象的一种特殊的成员函数
- 只要类的对象被创建，就会初始化构造函数
## 默认构造函数
- 没有提供任何实参时使用的构造函数
- ### 合成的默认函数
  - 当类没有显示地定义构造函数，编译器会隐式的定义一个默认构造函数
  - 其初始化类的数据成员的规则为：
    - 如果存在类内的初始值，用它来初始化
    - 否则，默认初始化该成员
- ### 不适用合成的默认函数情况
  - 定义了其他构造函数
    - 除非再定义一个默认构造函数，否则类将没有默认构造函数
  - 含有内置类型或复合类型成员的类
    - 这些类型的默认初始化值是未定义，创建对象可能会得到未定义的值
    - 应在类的内部初始化这些成员，或自己定义默认初始化构造函数
  - 编译器不能为某些类合成默认的构造函数
    - 如含有一个其他类类型的成员
- ### = default
  - 写在参数列表后，要求编译器生成构造函数
  ```c++
  Cex::Cex() = default;
  ```
## 构造函数初始值列表
```c++
Cex(const std::string &s) : str(s) { }
Cex(const std::string &s,int i) : str(s), x(i) { }
```

# 友元
- 类向外部提供非公有成员访问权限，友元可以是类，也可以是函数
- 只能出现在类定义的内部
- 使用方法：增加一条以**friend**关键字开始的函数声明即可
  - 仅指定了访问权限，**并非函数声明**，还需再专门对函数进行一次声明
  ```c++
  friend void example();
 
  ```
# 类的声明
- 可以把类的声明与定义分开
```c++
class Screen;   //Screen类的声明
```
- 这种声明被称为**前向声明**
- 在声明之后，定义之前，为**不完全类型**
  - 可以定义指向该类型的指针或引用
  - 可以声明也不完全类型作为参数或返回类型的函数