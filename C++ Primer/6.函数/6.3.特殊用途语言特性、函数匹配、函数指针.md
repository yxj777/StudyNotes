# 特殊用途语言特性
- ## 默认实参
  - 当调用缺少了某个实参时，为该实参指定**默认实参**
  - 调用含有默认实参的函数，可包含实参，也可以忽略实参
  - 一旦某个形参被赋予了默认值，它后面的所有形参必须都有默认值
  - ### 默认实参声明
    - 在给定的作用域中，一个形参只能被赋予**一次**默认实参
    - 通常默认实参的声明放在头文件中
  - ### 默认实参初始值
    - 局部变量不能作为默认实参
    - 只要表达式的类型能转换为形参所需要的类型，该表达式就能作为默认实参
        ```c++
        sz wd=80;
        char def=' ';
        sz ht();
        string screen(sz=ht(),sz=wd,char=def);
        string window=screen();         //调用screen(ht(),80,' ')
        void f2()
        {
            def='*';            //改变默认形参值
            sz wd=100;          //隐藏了外层定义的wd，但没有改变默认值
            window=screen();    //调用screen(ht(),80,'*')
        }
        ```
- ## 内联函数（inline）
  - 请求编译器在可能得情况下在调用点展开函数，可以避免常见的调用开销
  - 一般用于优化规模小、流程直接、频繁调用的函数
  - 内类函数放在头文件中
    ```c++
    inline int add(int a,int b)
    {
        return a+b;
    }
    int main()
    {
        int num1=1;
        int num2=2;
        int myNum=add(num1,num2)
        //内联后为 int myNum=num1+num2;
    }
    ```
- ## constexpr函数
  - 可以返回常量表达式的函数，一个constexpr函数被隐式的声明成内联函数
  - constexpr函数放在头文件中
  - ## constexpr规则
    - 函数的返回类型及所有形参的类型为字面值类型
    - 函数体中必须有且只有一条 return 语句
    - 可以包含不执行任何操作的语句，如空语句，类型别名以及using
    - 允许constexpr函数返回一个非常量
- ## 调试帮助
  - ### assert预处理宏
    ```c++
    assert(expr)
    ```
    - 先对expr求值，如果表达式为假，assert输出信息并终止程序的执行，如果为真，就什么也不做
    - 定义在 **cassert** 头文件中
    - 常用于检查“不能发生”的条件中
- ## NDEBUG预处理变量
  - 可以使用 #define 定义NDEBUG，默认未定义
  - 如果定义了NDEBUG，则assert什么都不做，反之，assert将执行时检查
  - 也可以同 #ifndef 和 #endif 编写自己的调试代码
    ```c++
    #ifndef NDEBUG
    ...
    #endif
    ```

# 函数匹配（步骤）
  ```c++
  void f();
  void f(int);
  void f(int,int);
  void f(double,double=3.14);
  f(5.6);     //调用f(double,double)
  //四个都为候选函数
  //f(int)与f(double,double=3.14)为可行函数
  //f(double,double=3.14)最匹配，接收一个实参且类型相同
  ```
- ## 1.候选函数
  - 选定调用对应的重载函数集，集合中的函数为**候选函数**
  - ### 候选函数特征
    - 与被调函数同名
    - 声明在调用点可见
- ## 2.可行函数
  - 考察本次调用提供的实参，从候选函数中选出能被这组实参调用的函数，选出的函数为**可行函数**
  - ## 可行函数特征
    - 形参数量与调用提供的实参数量相等
    - 每个实参的类型与对应的形参类型相同，或者能转换成形参的类型
- ## 3.寻找最佳匹配
  - 从可行函数中挑选与本次调用最匹配的函数
    - 实参类型与形参类型越接近，匹配的越好
- ## 含有多个形参的函数匹配
- 如果有且只有一个函数满足下列条件，则匹配成功
  - 该函数每个实参的匹配不劣与其他可行函数需要的匹配
  - 至少有一个形参的匹配由于其他可行函数的匹配
- 如果没有，则编译器报告**二义性调用**
- ## 实参类型转换
  - ### 转换等级
    - 1.精准匹配
      - 实参类型与形参类型相同
      - 实参从数组类型或函数类型转换成对应的指针类型
      - 向实参添加顶层const或从实参中删除顶层const
    - 2.通过const转化实现的匹配
    - 3.通过类型提升实现的匹配
    - 4.通过算术转换或者指针转换实现的匹配
    - 5.通过类类型转换实现的匹配

# 函数指针
- ## 指针函数的声明
  ```
  类型 (*指针名) (形参...){...}
  ```
  ```c++
  //案例
  bool (*pf)(const string &,const string &)
  ```
- ## 函数指针的使用
  - 把函数名当做值使用时，函数自动转换成**指针**
    ```c++
    pf=func();    //pf指向名为func的函数
    pf=&func()    //等价，&可选
    ```
  - 可以使用指向函数的指针调用该函数，且无需解引用
    ```c++
    //三个等价
    bool b1=pf("111","222");
    bool b1=(*pf)("111","222");
    bool b1=func("111","222");
    ``` 
  - 指向不同函数类型的指针不存在转换规则，但可以为0或nullptr
    ```c++
    int hs1(const string &,const string &);
    bopl hs2(const string &);
    pf=0;     //正确
    pf=hs1;    //错误，返回类型不匹配
    pf=hs2;    //错误，形参类型不匹配
    ```
- ## 重载指针函数
  - 编译器通过指针类型决定用哪个函数，指针类型必须与重载函数中的某个一个精确匹配
    ```c++
    void ff(int*);
    void ff(unsigned int);

    void (*pf1)(unsigend int)=ff   //正确，指向ff(unsigned);
    void (*pf2)(int)=ff;           //错误，无匹配
    void (*pf3)(int*)=ff;          //错误，返回类型不匹配
    ```

- ## 函数指针形参
  - 类似指针，虽然不能定义函数类型的形参，但是可以当成指针使用
    ```c++
    void fun(int a,int b,bool pf(int a,int b));
    void fun(int a,int b,bool (*pf)(int a,int b));    //等价类型
    ```
  - 可以使用类型别名与decltype简化
- ## 返回指向函数的指针
  - ### 使用类型别名
    - 同数组类似，使用类型别名更简单
    ```c++
    using F=int(int*,int);        //F是函数类型，不是指针
    using PF=int(*)(int*,int);    //PF为指针类型
    F f1(int)；    //错误，f1不能返回函数
    F *f1(int);
    PF f1(int);   //正确，返回函数的指针
    ```
  - ### 直接声明
    ```c++
    int (*f1(int))(int*,int);
    ```
  - ### 尾置返回类型
    ```c++
    auto f1(int) -> int(*)(int*,int)
    ```
  - ### 使用auto和decltype
    - 明确知道返回哪个函数，可以使用